<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<!-- saved from url=(0055)http://www.csc.ncsu.edu/faculty/jiang/csc501/labs/lab0/ -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  
  
  <meta name="GENERATOR" content="Mozilla/4.79 [en] (X11; U; Linux 2.4.17 i686) [Netscape]">
  <title>Lab 0: Getting Acquainted with XINU</title>
<style type="text/css"></style></head>
<body>
<center>
<h2>CSC501 Spring 2009</h2>
</center>
<center>
<h2>Lab 0: Getting Acquainted with XINU</h2>
</center>
<center>
<h2>Due: Jan. 20th 2009</h2>
</center>
<h2>1. Objectives</h2>
The objectives of this introductory lab are to familiarize you with the process
of compiling and running XINU, the tools involved, and the run-time environment
and segment layout.
<hr width="100%">
<h2>2. Readings</h2>
<ol>
  <li>    <i><a href="http://www.csc.ncsu.edu/faculty/jiang/csc501/labs/setup.html">Lab setup guide</a></i></li>
  <li>The Intel manuals which are available on the 
<!-- <a href="../index.html#readings">class web page</a> or the -->
<a href="http://www.csc.ncsu.edu/faculty/jiang/csc501/labs/labs.html">main lab web page</a>, as well as on the Intel web site.</li>
  <li>AT&amp;T assembly information specific to the gnu assembler is <a href="http://en.wikibooks.org/wiki/X86_Assembly/GAS_Syntax">available here</a> as a wikibook.
<!-- linked through the <a
 href="../index.html#readings">class web page</a> or the <a
 href="../labs.html">main lab web page</a>.</li> -->
  </li><li>Any man pages/manuals you discover that you need.</li>
</ol>
Note: The Intel document is hundreds of pages long and there is no need to
print it. Please do not print it!
<hr width="100%">
<h2>3. What to do</h2>
You will be using the lab0-spring09.tgz you have downloaded and compiled
by following the <a href="http://www.csc.ncsu.edu/faculty/jiang/csc501/labs/setup.html">lab setup guide</a>. And you are asked to write several
XINU functions that perform the following:
<p>&nbsp;&nbsp;&nbsp; 1. <b><i>long net2hostl_asm (long param)</i></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Convert the parameter <i>param</i> from network byte order (always Big Endian)
to host byte order.&nbsp; The code for this function should be entirely written
in x86 assembly. You should <b><i>not use</i></b> in-line assembly (i.e.,
do not&nbsp; use asm("...")).&nbsp; You can assume that the size of long
is 4 bytes and the byte order of the host machine is Little Endian.&nbsp;
To investigate the assembly code generated by the compiler, you can use the tool <b><i>objdump
-d &lt;___.o&gt;</i></b> to disassemble an object file.&nbsp; The object
files reside in the /compile directory within the main Xinu directory. You can also see some of
the *.S files in the /sys directory for reference.</p>
<p>&nbsp;&nbsp;&nbsp; 2.&nbsp; <b><i>void printsegaddress()</i></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Print the address of
the end of the text, data, and bss segments of the Xinu OS. 
Also print the 4 bytes (in hexadecimal) preceding the end of the
three segment boundaries, and similarly for the 4 bytes following
the segment boundaries. This function can be written
in C.</p>
<p>&nbsp;&nbsp;&nbsp; 3.&nbsp;&nbsp; <b><i>void printtos()</i></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Print the address
of the top of the run-time stack for whichever process you are currently
in.&nbsp; In addition, print the contents of up to five stack locations at
and below the top of the stack (the five or fewer items that have been the
most recently pushed, if any). Remember that stack elements are 32 bits wide,
and be careful to perform pointer arithmetic correctly.&nbsp; Also note that
there are local variables and arguments on the stack, among other things.
See the hints given for #4 below, especially on stacktrace.c and proc.h.
Your function can be written entirely in C, or you can use in-line assembly
if you prefer.</p>
<p>&nbsp;&nbsp;&nbsp; 4.&nbsp;&nbsp; <b><i>void printprocstks()</i></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; For each
existing process, print the <i>stack base</i>, <i>stack size</i>,<i>stack
limit</i>, and <i>stack pointer</i>. Also, for each process, include the
<i>process name</i> and the <i>process id</i>. An example output might look
something like:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Proc [prnull]. Pid = 0.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Stack:
Base&nbsp; = 4095996<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Len&nbsp;&nbsp; = 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Limit = 4091904<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
StkPtr&nbsp; = 4095820</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Proc [main]. Pid = 49.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Stack:
Base&nbsp; = 4091896<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Len&nbsp;&nbsp; = 4096<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Limit = 4087804<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
StkPtr&nbsp; = 4091872</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; To help you do this, please
look into <b>proc.h</b> in the <b>h/</b> directory.&nbsp; Note the <i>proctab[]</i>
array that holds all processes. Also, note that the <i>pesp</i> member of
the <i>pentry</i> structure holds the <i>saved</i> stack pointer.&nbsp; Therefore,
the <i>currently</i> executing process has a stack pointer that is different
from the value of this variable.&nbsp; In order to help you get the stack
pointer of the currently executing process, carefully study the <b>stacktrace.c</b>
file in the <b>sys/</b>directory.&nbsp; The register <i>%esp</i> holds the
current stack pointer.&nbsp; You can use in-line assembly (i.e., asm("..."))
to do this part.<br>
&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp; Implement this lab as a set of functions that can be
called from main().&nbsp; Each function should reside in a separate file
in the <i>sys</i> directory, and should be incorporated into the Makefile.&nbsp;
The files should be named after the functions they are implementing with C
files having the<b>.c</b> extension and the assembly files having the<b>.S</b>
extension.&nbsp; So, for example, the file that will hold <b><i>void printsegaddress()</i></b>
should be named <b><i>printsegaddress.c</i></b>; and the file that will hold
<b><i>long net2hostl_asm(long param)</i></b> should be named <b><i>net2hostl_asm.S</i></b>.&nbsp;
If you require a header file, please name it <b>lab0.h</b>.&nbsp; Note: as
you create new files, you may need to update the Makefile (located in the
compile/ directory) to configure it to compile your files correctly. Just
look at what is done for the existing files (e.g., main.c) to see what you
have to do.</p>
<p></p>
<hr width="100%">
<h2><b>4. Additional Questions</b></h2>
<b>&nbsp;&nbsp;&nbsp;&nbsp;</b>&nbsp; Write your answers to the following
questions in a file named <b>Lab0Answers.txt</b>(in simple text).
Please place this
file in the <b>sys/</b> directory and turn it in, along with the above programming
assignment.
<ol>
  <li>Assuming the XINU text begins at address 0x0, draw a rough diagram
of XINU's memory layout with addresses derived from your experimental measurements.&nbsp;
Include the information you uncovered from running your version of <b><i>printsegaddress()</i></b>
and <b><i>printprocstks().</i></b></li>
  <li>Draw a rough layout of the stack for a user process based on your measurements.
Show the relative locations of local variables and arguments. If you found
other information about the stack, include it on the diagram. What other items
would be found on a stack that are not included in your diagram?&nbsp; Include
the information you uncovered from running your version of <b><i>printtos().</i></b></li>
  <li>Briefly describe the mov instruction in the x86.</li>
  <li>Briefly describe the push, pusha, pop, and popa instructions in the
x86.</li>
</ol>
<hr width="100%">
<h2><b>Turn-in Instructions</b></h2>
<p><i>Electronic turn-in instructions:</i></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i) go to the csc501-lab0/compile
directory and do "make clean".</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ii) go to the directory of which
your csc501-lab0 directory is a subdirectory (NOTE: please do not rename csc501-lab0,
or any of its subdirectories.)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
e.g., if /home/csc501/csc501-lab0 is your directory structure, goto /homes/csc501/
</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iii) create a subdirectory TMP (under the directory csc501-lab0) and copy all the files you have modified/written, both  .c files and .h
files into the directory. 

</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iv) compress the csc501-lab0 directory
into a tgz file and use Wolfware's <a href="http://submit.ncsu.edu/">Submit Assignment</a>
 facility. Please only upload one tgz file.
</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
tar czf csc501-lab0.tgz csc501-lab0</p>
<p></p>
<p><b><i>You can write code in main.c to test your procedures,
but please note that when we test your programs we will replace the main.c
file! Therefore, do not put any functionality in the main.c file.</i></b>
<br>
</p>
<p><b><i>Also, ALL debugging output should be turned off before you submit your code.</i></b>
<br>
</p>

<hr><a href="http://www.csc.ncsu.edu/faculty/jiang/csc501/index.html">Back to the CSC501 web page</a><br>


</body></html>